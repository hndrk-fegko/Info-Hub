# SOFTWARE DEVELOPMENT GUIDELINES F√úR KI-AGENTEN
Version 1.0 | Letzte Aktualisierung: November 2025

Diese Richtlinien M√úSSEN bei JEDER Codeentwicklung, Refactoring und Projekterstellung befolgt werden.

---

## 1. PROJEKTSTRUKTUR & ORGANISATION

### 1.1 Verzeichnisstruktur
Jedes Projekt MUSS folgende klare Trennung aufweisen:

```
/
‚îú‚îÄ‚îÄ src/                    # Quellcode (Codebase)
‚îÇ   ‚îú‚îÄ‚îÄ core/              # Kernfunktionalit√§t
‚îÇ   ‚îú‚îÄ‚îÄ modules/           # Wiederverwendbare Module
‚îÇ   ‚îú‚îÄ‚îÄ config/            # Konfigurationsdateien
‚îÇ   ‚îî‚îÄ‚îÄ utils/             # Hilfsfunktionen
‚îú‚îÄ‚îÄ docs/                  # Dokumentation
‚îÇ   ‚îú‚îÄ‚îÄ dev/              # Entwicklerdokumentation
‚îÇ   ‚îú‚îÄ‚îÄ admin/            # Administrator-Dokumentation
‚îÇ   ‚îî‚îÄ‚îÄ user/             # Benutzerdokumentation
‚îú‚îÄ‚îÄ tests/                 # Test-Suite
‚îÇ   ‚îú‚îÄ‚îÄ unit/             # Unit-Tests
‚îÇ   ‚îú‚îÄ‚îÄ integration/      # Integrationstests
‚îÇ   ‚îî‚îÄ‚îÄ e2e/              # End-to-End-Tests
‚îú‚îÄ‚îÄ data/                  # Benutzerdaten & Laufzeitdaten
‚îî‚îÄ‚îÄ logs/                  # Log-Dateien
```

### 1.2 Namenskonventionen
- **Konsistenz**: Einheitliche Namensgebung projekt√ºbergreifend
- **Modulpr√§fixe**: Variablen in Modulen enthalten den Modulnamen als Pr√§fix
  - Beispiel: `loggerConfig`, `loggerInstance`, `loggerUtils`
- **Dateibenennung**: Kleinbuchstaben mit Bindestrichen oder CamelCase je nach Sprache
- **Funktionen**: Verben verwenden (`getUserData`, `validateInput`, `initializeModule`)
- **Konstanten**: UPPERCASE mit Unterstrichen (`MAX_RETRIES`, `DEFAULT_TIMEOUT`)

---

## 2. LOGGING, DEBUGGING & ERROR TRACKING

### 2.1 Zentrales Logging-System
JEDES Projekt ben√∂tigt von Anfang an ein zentrales Logging-System.

### 2.2 Pflichtfelder f√ºr jeden Log-Eintrag
Jeder Log-Eintrag MUSS folgende Informationen enthalten (sofern verf√ºgbar):

```
{
  "timestamp": "ISO 8601 Format",
  "level": "INFO | ERROR | DEBUG | WARNING | EXCEPTION | SUCCESS | FAILURE | ANNOUNCEMENT",
  "module": "Modulname",
  "file": "Dateiname mit Pfad",
  "line": "Zeilennummer",
  "function": "Funktionsname",
  "message": "Beschreibung der Meldung",
  "context": "Zus√§tzliche Kontextinformationen",
  "stackTrace": "Bei Fehlern: vollst√§ndiger Stack Trace"
}
```

### 2.3 Log-Level Verwendung
- **DEBUG**: Detaillierte Informationen f√ºr Entwicklung
- **INFO**: Allgemeine Informationen √ºber Programmablauf
- **WARNING**: Potenzielle Probleme, System l√§uft aber weiter
- **ERROR**: Fehler, die behandelt werden k√∂nnen
- **EXCEPTION**: Unbehandelte Exceptions
- **SUCCESS**: Erfolgreiche Abschl√ºsse wichtiger Operationen
- **FAILURE**: Fehlgeschlagene Operationen
- **ANNOUNCEMENT**: Neue Features, Updates, Neuigkeiten (wird z.B. genutzt um User √ºber neue Funktionen zu informieren)

### 2.4 Integration & Wiederverwendbarkeit
- Alle Systemkomponenten loggen in das zentrale System
- Module k√∂nnen sich hier einh√§ngen und bestimmte Nachrichten als Trigger benutzen
- Beispiel: Toast-Benachrichtigungs-Modul liest aus dem zentralen Log-Stream und gibt Success, FAILURE und ANNOUNCEMENT im Frontend aus.

---

## 3. MODULARE ARCHITEKTUR

### 3.1 Grundprinzipien
- **Maximale Modularit√§t**: Jede Funktionalit√§t als eigenst√§ndiges Modul
- **Wiederverwendbarkeit**: Code so schreiben, dass er in anderen Projekten nutzbar ist
- **Plugin-Architektur**: Hook-Points f√ºr Erweiterungen definieren

### 3.2 Plugin/Hook-System
Module m√ºssen sich an definierten Einh√§ngepunkten registrieren k√∂nnen:

**Hook-Beispiele:**
- `onAppInit`: Initialisierung beim Start
- `onConfigLoad`: Konfiguration geladen
- `registerMenuItem`: Men√ºeintr√§ge hinzuf√ºgen
- `registerSettingsPanel`: Einstellungs-Panels registrieren
- `registerRoute`: Routen registrieren (Webapps)
- `onBeforeShutdown`: Vor dem Beenden

### 3.3 Modul-Integration
**Frage: Wie integrieren Module ihre Assets (API, CSS, JS)?**

**Antwort & Implementierung:**
1. **Manifest-Datei**: Jedes Modul hat eine `module.json` mit Metadaten:
   ```json
   {
     "name": "moduleName",
     "version": "1.0.0",
     "assets": {
       "css": ["styles/main.css"],
       "js": ["scripts/init.js"],
       "api": ["api/endpoints.js"]
     },
     "hooks": ["onAppInit", "registerMenuItem"],
     "dependencies": ["loggerModule", "configModule"]
   }
   ```

2. **Asset-Loader**: Zentraler Loader l√§dt Assets beim Modulstart
3. **API-Registry**: Zentrale API-Registry registriert Endpunkte
4. **Dependency Injection**: Module erhalten ben√∂tigte Dependencies injiziert

---

## 4. LAYERED ARCHITECTURE (SCHICHTENARCHITEKTUR)

### 4.1 Prinzip der Abstraktion
Gesch√§ftslogik NIEMALS direkt an Implementierungsdetails koppeln.

### 4.2 Standard-Layer
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Presentation Layer (UI)       ‚îÇ  ‚Üê Nutzt nur Service Layer
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Service/Business Logic Layer  ‚îÇ  ‚Üê Nutzt nur Data Access Layer
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Data Access Layer (DAL)       ‚îÇ  ‚Üê Abstrakte Interfaces
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Implementation Layer          ‚îÇ  ‚Üê Konkrete Implementierungen
‚îÇ   (JSON, Database, API)         ‚îÇ     (austauschbar)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 4.3 Praktisches Beispiel

**Falsch:**
```javascript
// Frontend direkt gekoppelt an JSON
function saveUserData(user) {
  fs.writeFileSync('data.json', JSON.stringify(user));
}
```

**Richtig:**
```javascript
// Frontend nutzt abstrakten Service
function saveUserData(user) {
  dataService.save('users', user);
}

// Data Service Layer (Interface)
class DataService {
  save(entity, data) {
    return this.storage.save(entity, data);
  }
}

// Implementation Layer (austauschbar)
class JsonStorage { save(entity, data) { /* JSON */ } }
class DatabaseStorage { save(entity, data) { /* SQL */ } }
```

**Vorteil:** Migration von JSON zu Datenbank erfordert nur Austausch der Storage-Implementierung, kein Frontend-Code wird angefasst.

### 4.4 Skalierungsplanung
Skalierungspl√§ne M√úSSEN in `docs/dev/vision.md` und `docs/dev/roadmap.md` dokumentiert werden:
- Soll das System skaliert werden, wenn ja wie (mehr installationen, mehr Daten, etc.) und wie gro√ü (anzahl der Nutzer, Anzahl der Daten, etc.)
- Welche Layer werden bei Wachstum ausgetauscht?
- Welche Technologien sind f√ºr Skalierung vorgesehen?
- Ab welchen Metriken wird skaliert?

---

## 5. DOKUMENTATION

### 5.1 Dokumentationspflicht
Dokumentation ist KEIN Optional, sondern Teil der Definition of Done.

### 5.2 Zielgruppenspezifische Dokumentation

#### A) Entwicklerdokumentation (`docs/dev/`) - KI-OPTIMIERT
1. **vision.md**
   - Projektziele & Langzeitvision
   - Erfolgskriterien
   - Zielgruppe & Use Cases

2. **architecture.md**
   - Systemarchitektur-Diagramme
   - Komponenten & deren Interaktionen
   - Design Patterns & Begr√ºndungen
   - Datenfl√ºsse

3. **codebase.md**
   - Verwendete Programmiersprachen & Versionen
   - Abh√§ngigkeiten & Pakete
   - Development Setup (Schritt-f√ºr-Schritt)
   - Build- & Deployment-Prozess
   - Code-Konventionen

4. **roadmap.md** & **changelog.md**
   - Geplante Features nach Priorit√§t
   - Versionshistorie mit Breaking Changes
   - Migration Guides

5. **api.md** & **interfaces.md**
   - Alle √∂ffentlichen APIs dokumentiert
   - Schnittstellen zwischen Modulen
   - Datenmodelle & Schemas

#### B) Administrator-Dokumentation (`docs/admin/`)
1. **deployment.md**
   - Installationsanleitung
   - Konfiguration
   - Wartung & Updates
   - Monitoring & Logging
   - Backup & Recovery

#### C) Benutzerdokumentation (`docs/user/`)
1. **user-guide.md**
   - Bedienungsanleitung mit Screenshots
   - H√§ufige Workflows
   - FAQ
   - Troubleshooting

### 5.3 Modul-spezifische Dokumentation
Jedes Modul KANN eine eigene `README.md` im Modulverzeichnis haben:
- Zweck des Moduls
- √ñffentliche API
- Konfigurationsoptionen
- Verwendungsbeispiele
- Dependencies

### 5.4 Dokumentations-Workflow
**WICHTIG:**
- ‚úÖ Bestehende Dokumente √ºberarbeiten statt neue erstellen
- ‚úÖ Dokumentation aktualisieren bei Code√§nderungen
- ‚úÖ √Ñnderungen im Changelog dokumentieren

---

## 6. ARBEITSABLAUF & BEST PRACTICES

### 6.1 Aufgabengr√∂√üe & Komplexit√§t managen

**KRITISCH f√ºr KI-Agenten:**
Gro√üe, komplexe Aufgaben M√úSSEN in kleine, handhabbare Schritte zerlegt werden.

**Faustregel f√ºr Aufgabengr√∂√üe:**
- ‚úÖ **Optimal**: 1-3 Dateien bearbeiten, 10-50 Zeilen Code
- ‚ö†Ô∏è **Akzeptabel**: 3-5 Dateien, 50-100 Zeilen Code
- ‚ùå **Zu gro√ü**: Mehr als 5 Dateien oder > 100 Zeilen - AUFTEILEN!

**Warum kleinschrittig?**
- KI-Agenten verlieren bei gro√üen Aufgaben den √úberblick
- Fehler sind leichter zu identifizieren
- Fortschritt ist messbar und nachvollziehbar
- R√ºcksprung bei Problemen ist einfacher

### 6.2 Vor jeder Implementierung: Fragen stellen
**Vor dem Coding IMMER pr√ºfen:**
- ‚ùì Gibt es bereits √§hnlichen Code, der wiederverwendet werden kann?
- ‚ùì Ist diese Funktionalit√§t wirklich notwendig (YAGNI-Prinzip)?
- ‚ùì Wie f√ºgt sich dies in die bestehende Architektur ein?
- ‚ùì Welche Dokumentation muss aktualisiert werden?
- ‚ùì **Ist diese Aufgabe klein genug? Kann sie weiter unterteilt werden?**

**Regel:** Lieber eine Frage mehr als Code doppelt schreiben!

### 6.3 Standard-Arbeitsschritte f√ºr einfache Aufgaben

**JEDE Implementierung folgt diesem Workflow:**

1. **Todo-Liste erstellen**
   - Detaillierte Aufgabenliste mit Checkboxen
   - Abh√§ngigkeiten identifizieren
   - Zeitsch√§tzungen hinzuf√ºgen

2. **Einordnung in Projektstruktur**
   - Wo geh√∂rt der Code hin?
   - Welche Module sind betroffen?
   - Welche Schnittstellen werden ber√ºhrt?

3. **Dokumentation sichten**
   - Relevante Abschnitte in `docs/` lesen
   - Architektur-Constraints pr√ºfen
   - Bestehende Patterns identifizieren

4. **Vision & Erfolgskriterien abgleichen**
   - Passt die L√∂sung zur Projektvision?
   - Erf√ºllt sie die Erfolgskriterien?
   - Gibt es bessere Alternativen?

5. **Implementierung**
   - Code schreiben nach den definierten Standards
   - Tests parallel entwickeln (TDD bevorzugt)
   - Logging-Statements hinzuf√ºgen
   - Code-Kommentare f√ºr komplexe Logik

6. **Dokumentation aktualisieren**
   - Betroffene Dokumente updaten
   - Changelog-Eintrag hinzuf√ºgen
   - API-Dokumentation erweitern
   - README bei Bedarf anpassen

7. **Review & Testing**
   - Unit-Tests ausf√ºhren
   - Integration-Tests pr√ºfen
   - Code-Review (oder Selbst-Review)
   - Erfolgskriterien validieren


### 6.4 Komplexe Aufgaben - Iterativer Workflow mit Arbeitsdokument

**F√ºr gro√üe Features, Refactorings oder Architektur-√Ñnderungen:**

#### Phase 1: Planung & Diskussion
1. **Arbeitsdokument erstellen** (tempor√§r im Workspace-Root oder `docs/wip/`)
   ```markdown
   # [WIP] Feature: [Name]
   Status: üü° In Planung
   
   ## 1. Beschreibung & Ziele
   - Was wird implementiert?
   - Warum ist es notwendig?
   - Welches Problem wird gel√∂st?
   
   ## 2. Betroffene Komponenten
   - Liste aller Module/Dateien
   - Abh√§ngigkeiten
   - Schnittstellen
   
   ## 3. Technisches Konzept
   - Architektur-Ansatz
   - Design Patterns
   - API-√Ñnderungen
   
   ## 4. Offene Fragen & Diskussion
   - ‚ùì Frage 1
   - ‚ùì Frage 2
   
   ## 5. Entscheidungen
   - ‚úÖ Entscheidung 1: Begr√ºndung
   - ‚úÖ Entscheidung 2: Begr√ºndung
   ```

2. **Alle Fragen kl√§ren**
   - Diskussion mit User/Team
   - Architektur-Entscheidungen dokumentieren
   - Alternativen bewerten und begr√ºnden

3. **Task-Unterteilung**
   - Feature in 5-10 kleine, unabh√§ngige Schritte zerlegen
   - Jeder Schritt max. 1-3 Dateien, 50 Zeilen Code
   - Reihenfolge und Abh√§ngigkeiten festlegen

#### Phase 2: Umsetzung mit Tracking
4. **Todo-Liste mit Fortschrittstracking im Arbeitsdokument**
   ```markdown
   ## 6. Implementierungs-Plan
   
   ### Sprint 1: Grundstruktur
   - [ ] Task 1.1: Logger-Modul Grundger√ºst erstellen
     - Dateien: `src/modules/logger/index.js`
     - Gesch√§tzt: 30min
   - [ ] Task 1.2: Config-Interface definieren
     - Dateien: `src/modules/logger/config.js`
     - Gesch√§tzt: 15min
   
   ### Sprint 2: Kern-Funktionalit√§t
   - [ ] Task 2.1: Log-Formatter implementieren
   - [ ] Task 2.2: File-Writer implementieren
   
   ### Sprint 3: Integration
   - [ ] Task 3.1: Ins Hauptsystem integrieren
   - [ ] Task 3.2: Tests schreiben
   
   ## 7. Fortschritt
   - ‚úÖ 2024-11-11 10:30 - Task 1.1 abgeschlossen
   - ‚úÖ 2024-11-11 11:00 - Task 1.2 abgeschlossen
   - üîÑ 2024-11-11 11:15 - Task 2.1 in Arbeit
   ```

5. **Schrittweise Implementierung**
   - EINEN Task nach dem anderen abarbeiten
   - Nach jedem Task: Commit + Tests
   - Fortschritt im Arbeitsdokument aktualisieren
   - Bei Problemen: Dokumentieren und Fragen stellen

#### Phase 3: Abschluss & Dokumentation
6. **Arbeitsdokument in finale Dokumentation √ºberf√ºhren**
   - Relevante Teile in `docs/dev/architecture.md` integrieren
   - API-√Ñnderungen in `docs/dev/api.md` eintragen
   - Feature-Beschreibung in `docs/dev/changelog.md` hinzuf√ºgen
   - Roadmap in `docs/dev/roadmap.md` aktualisieren

7. **Arbeitsdokument l√∂schen**
   - Tempor√§res `[WIP]`-Dokument entfernen
   - Alle wichtigen Infos sind jetzt in der offiziellen Doku

**Vorteile dieses Workflows:**
- ‚úÖ Klarer Fortschritt sichtbar
- ‚úÖ Diskussionen und Entscheidungen dokumentiert
- ‚úÖ Kleine, handhabbare Aufgaben
- ‚úÖ Keine Duplikate in der finalen Doku
- ‚úÖ Einfacher Wiedereinstieg nach Unterbrechungen

### 6.5 Dokumentenstruktur f√ºr Features/Module

**VERALTET - Verwende stattdessen den Workflow aus 6.4!**

F√ºr schnelle Referenz oder sehr kleine Features (< 3 Tasks):

```markdown
# Feature: [Name]

## 1. Beschreibung
Was wird implementiert und warum?

## 2. Technische Spezifikation
Wie wird es implementiert?

## 3. Betroffene Module
Welche Teile der Codebase werden ge√§ndert?

## 4. API-√Ñnderungen
Neue oder ge√§nderte Schnittstellen

## 5. Tests
Teststrategie & Testf√§lle

## 6. Migration
Wie werden bestehende User/Daten migriert?

## 7. Dokumentation
Welche Docs m√ºssen aktualisiert werden?
```

**Hinweis:** F√ºr alle komplexen Aufgaben verwende das ausf√ºhrliche Arbeitsdokument-Format aus 6.4!

### 6.6 Fortschrittsdokumentation w√§hrend der Arbeit

**WICHTIG:** Dokumentation ist kein einmaliger Schritt am Ende, sondern ein kontinuierlicher Prozess!

**W√§hrend der Implementierung MUSS dokumentiert werden:**

1. **Im Arbeitsdokument (`[WIP]`)**
   - ‚úÖ Abgeschlossene Tasks sofort abhaken
   - üìù Timestamp und Kurzbeschreibung hinzuf√ºgen
   - ‚ö†Ô∏è Probleme, Blockers und Workarounds notieren
   - üí° Erkenntnisse und Lessons Learned festhalten
   - üîÑ √Ñnderungen am urspr√ºnglichen Plan dokumentieren

2. **Im Code**
   - Aussagekr√§ftige Commit-Messages schreiben
   - Komplexe Logik mit Inline-Kommentaren erkl√§ren
   - TODO/FIXME-Marker f√ºr offene Punkte setzen
   - Deprecation-Warnings bei API-√Ñnderungen

3. **In Tests**
   - Test-Cases dokumentieren das erwartete Verhalten
   - Edge-Cases und Bug-Fixes als Tests festhalten

**Warum ist kontinuierliche Dokumentation wichtig?**
- KI-Agenten k√∂nnen Kontext bei langen Tasks verlieren
- Bei Unterbrechungen ist der Wiedereinstieg einfacher
- Entscheidungen und Begr√ºndungen gehen nicht verloren
- Die finale Dokumentation ist bereits zu 80% fertig

**Beispiel f√ºr gute Fortschrittsdokumentation:**
```markdown
## 7. Fortschritt

‚úÖ 2024-11-11 10:30 - Task 1.1 abgeschlossen
   - Logger-Grundger√ºst erstellt in src/modules/logger/
   - Entscheidung: Winston statt Custom-Logger (bessere Maintenance)

‚úÖ 2024-11-11 11:00 - Task 1.2 abgeschlossen
   - Config-Schema definiert mit JSON Schema Validation

üîÑ 2024-11-11 11:15 - Task 2.1 in Arbeit
   - Problem: Winston Transport Config komplex
   - Workaround: Wrapper-Klasse erstellt f√ºr Vereinfachung

‚ö†Ô∏è 2024-11-11 11:30 - Blocker bei Task 2.1
   - Winston unterst√ºtzt kein natives Log-Rotation
   - Frage an User: Separate Library einbinden oder Custom implementieren?
```

---

## 7. CODE-QUALIT√ÑT & STANDARDS

### 7.1 Code-Review Checkliste
Vor jedem Commit pr√ºfen:
- [ ] Code folgt Namenskonventionen
- [ ] Logging an kritischen Stellen implementiert
- [ ] Keine Code-Duplikation
- [ ] Funktionen haben Single Responsibility
- [ ] Tests geschrieben und bestanden
- [ ] Dokumentation aktualisiert
- [ ] Keine hartcodierten Werte (Config verwenden)
- [ ] Error Handling implementiert
- [ ] Security-Aspekte ber√ºcksichtigt

### 7.2 DRY (Don't Repeat Yourself)
- Duplizierten Code in Funktionen/Methoden extrahieren
- Gemeinsame Logik in Utility-Module auslagern
- Config-Werte zentral verwalten

### 7.3 SOLID-Prinzipien befolgen
- **S**ingle Responsibility
- **O**pen/Closed
- **L**iskov Substitution
- **I**nterface Segregation
- **D**ependency Inversion

### 7.4 Testing
- **Unit-Tests**: F√ºr jede Funktion/Methode
- **Integration-Tests**: F√ºr Modul-Interaktionen
- **E2E-Tests**: F√ºr kritische User-Journeys
- **Test Coverage**: Minimum 80% anstreben

---

## 8. ZUSAMMENFASSUNG DER KERNPRINZIPIEN

### Die 12 Gebote der Code-Qualit√§t:

1. **Struktur**: Klare Trennung von Code, Docs, Tests, Daten
2. **Logging**: Zentrales Logging von Tag 1
3. **Modularit√§t**: Maximale Wiederverwendbarkeit
4. **Layer**: Abstraktion durch Schichtenarchitektur
5. **Dokumentation**: Mehrere Zielgruppen, kontinuierlich aktualisiert
6. **Fragen**: Lieber fragen als doppelten Code schreiben
7. **Kleinschrittigkeit**: Gro√üe Aufgaben in kleine Tasks (max. 50 Zeilen) unterteilen
8. **Arbeitsdokumente**: Komplexe Features mit tempor√§rem WIP-Dokument planen
9. **Fortschritt dokumentieren**: W√§hrend der Arbeit, nicht nur am Ende
10. **Standards**: Konsistente Namensgebung & Conventions
11. **Testing**: Tests sind nicht optional
12. **Vision**: Jede Entscheidung gegen Vision abgleichen

### Workflow-Kurzreferenz

**Einfache Aufgabe (< 3 Dateien, < 50 Zeilen):**
‚Üí Direkt implementieren nach Standard-Workflow (6.3)

**Mittlere Aufgabe (3-5 Dateien oder 50-100 Zeilen):**
‚Üí Todo-Liste erstellen, dann implementieren

**Komplexe Aufgabe (> 5 Dateien oder > 100 Zeilen):**
‚Üí `[WIP]`-Arbeitsdokument erstellen (6.4)
‚Üí Feature in 5-10 kleine Tasks unterteilen
‚Üí Jeder Task einzeln umsetzen mit Fortschrittsdoku
‚Üí Am Ende: Erkenntnisse in offizielle Doku √ºberf√ºhren, WIP l√∂schen

---

## 9. CHECKLISTE F√úR NEUES PROJEKT

Beim Start eines neuen Projekts:


- [ ] Verzeichnisstruktur angelegt (`src/`, `docs/`, `tests/`, `data/`)
- [ ] Logging-System implementiert
- [ ] `docs/dev/vision.md` erstellt und ausf√ºhrlich diskutiert
- [ ] `docs/dev/roadmap.md` erstellt 
- [ ] `docs/dev/architecture.md` erstellt
- [ ] `docs/dev/codebase.md` erstellt
- [ ] `.gitignore` konfiguriert
- [ ] `README.md` mit Quick-Start
- [ ] Test-Framework eingerichtet
- [ ] CI/CD Pipeline konfiguriert (wenn zutreffend)
- [ ] Namenskonventionen definiert
- [ ] Code-Style Guide gew√§hlt (ESLint, Prettier, etc.)

---

**Ende der Richtlinien**

*Diese Richtlinien sind ein lebendes Dokument und sollten bei Bedarf aktualisiert werden.* 